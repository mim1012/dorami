# Staging Deployment Workflow
# Automatically deploys to staging when code is pushed to develop branch
# Can also be triggered manually

name: Deploy to Staging

on:
  push:
    branches: [develop]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests before deployment'
        required: false
        default: 'false'
        type: boolean

concurrency:
  group: staging-deployment
  cancel-in-progress: false

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/dorami

jobs:
  # ===========================================
  # Run CI Tests First
  # ===========================================
  test:
    name: Run Tests
    if: ${{ github.event_name != 'workflow_dispatch' || !inputs.skip_tests }}
    uses: ./.github/workflows/ci.yml

  # ===========================================
  # Build and Push Docker Images (unified)
  # ===========================================
  build:
    name: Build Images
    needs: [test]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    uses: ./.github/workflows/build-images.yml
    permissions:
      contents: read
      packages: write

  # ===========================================
  # Deploy to Staging Server
  # ===========================================
  deploy:
    name: Deploy to Staging
    needs: [build]
    if: always() && needs.build.result == 'success'
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: ${{ vars.STAGING_URL }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup SSH
        env:
          SSH_KEY: ${{ secrets.STAGING_SSH_KEY }}
          SSH_HOST: ${{ secrets.STAGING_HOST }}
        run: |
          mkdir -p ~/.ssh
          KEY_OK=false
          printf '%s\n' "$SSH_KEY" | tr -d '\r' > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          if ssh-keygen -y -f ~/.ssh/id_rsa > /dev/null 2>&1; then
            echo "SSH key loaded (raw PEM)"
            KEY_OK=true
          fi
          if [ "$KEY_OK" = "false" ]; then
            if printf '%s' "$SSH_KEY" | tr -d ' \r\n' | base64 -d > ~/.ssh/id_rsa 2>/dev/null; then
              chmod 600 ~/.ssh/id_rsa
              if ssh-keygen -y -f ~/.ssh/id_rsa > /dev/null 2>&1; then
                echo "SSH key loaded (base64)"
                KEY_OK=true
              fi
            fi
          fi
          if [ "$KEY_OK" = "false" ]; then
            echo "ERROR: SSH key invalid. len=${#SSH_KEY} has_begin=$(printf '%s' "$SSH_KEY" | grep -c BEGIN || echo 0)"
            exit 1
          fi
          ssh-keyscan -H "$SSH_HOST" >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Validate image tag format
        env:
          IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
        run: |
          if [[ ! "$IMAGE_TAG" =~ ^sha-[0-9a-f]{40}$ ]]; then
            echo "ERROR: IMAGE_TAG must match sha-<40hex>, got: ${IMAGE_TAG}"
            exit 1
          fi
          echo "Validated IMAGE_TAG: ${IMAGE_TAG}"

      - name: Deploy via SSH
        env:
          HOST: ${{ secrets.STAGING_HOST }}
          USER: ${{ secrets.STAGING_USER }}
          IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          KAKAO_CLIENT_ID: ${{ secrets.STAGING_KAKAO_CLIENT_ID }}
          KAKAO_CLIENT_SECRET: ${{ secrets.STAGING_KAKAO_CLIENT_SECRET }}
          ADMIN_EMAILS: ${{ secrets.STAGING_ADMIN_EMAILS }}
        run: |
          ssh $USER@$HOST << ENDSSH
            set -e

            cd /opt/dorami

            echo "=== Pulling latest code ==="
            git fetch origin ${{ github.ref_name }}
            git reset --hard origin/${{ github.ref_name }}

            echo "=== Cleaning up old images ==="
            docker image prune -af --filter "until=24h" || true
            docker builder prune -af --filter "until=24h" || true
            echo "Disk usage after cleanup:"
            df -h / | tail -1

            echo "=== Logging into GHCR ==="
            echo "${GHCR_TOKEN}" | docker login ghcr.io -u ${GITHUB_REPOSITORY_OWNER} --password-stdin

            echo "=== Loading environment for staging compose ==="
            export IMAGE_TAG=${IMAGE_TAG}
            export GITHUB_REPOSITORY_OWNER=${GITHUB_REPOSITORY_OWNER}
            export STAGING_HOST=${HOST}
            export KAKAO_CLIENT_ID=${KAKAO_CLIENT_ID}
            export KAKAO_CLIENT_SECRET=${KAKAO_CLIENT_SECRET}
            export ADMIN_EMAILS=${ADMIN_EMAILS}
            if [ -f .env.staging ]; then
              set -a
              . ./.env.staging
              set +a
            fi

            docker compose -f docker-compose.base.yml -f docker-compose.staging.yml pull
            echo "=== Verifying pulled staging image tags are immutable sha ==="
            BACKEND_IMAGE_REF="ghcr.io/${GITHUB_REPOSITORY_OWNER}/dorami-backend:${IMAGE_TAG}"
            FRONTEND_IMAGE_REF="ghcr.io/${GITHUB_REPOSITORY_OWNER}/dorami-frontend:${IMAGE_TAG}"
            BACKEND_IMAGE_ID=$(docker image inspect --format='{{.Id}}' "$BACKEND_IMAGE_REF")
            FRONTEND_IMAGE_ID=$(docker image inspect --format='{{.Id}}' "$FRONTEND_IMAGE_REF")
            if [[ ! "$BACKEND_IMAGE_REF" =~ ^ghcr\.io/${GITHUB_REPOSITORY_OWNER}/dorami-backend:sha-[0-9a-f]{40}$ ]]; then
              echo "ERROR: backend image ref is not immutable sha tag: $BACKEND_IMAGE_REF"
              exit 1
            fi
            if [[ ! "$FRONTEND_IMAGE_REF" =~ ^ghcr\.io/${GITHUB_REPOSITORY_OWNER}/dorami-frontend:sha-[0-9a-f]{40}$ ]]; then
              echo "ERROR: frontend image ref is not immutable sha tag: $FRONTEND_IMAGE_REF"
              exit 1
            fi
            if [ "$BACKEND_IMAGE_REF" != "ghcr.io/${GITHUB_REPOSITORY_OWNER}/dorami-backend:${IMAGE_TAG}" ]; then
              echo "ERROR: backend image mismatch (expected ghcr.io/${GITHUB_REPOSITORY_OWNER}/dorami-backend:${IMAGE_TAG}, got $BACKEND_IMAGE_REF)"
              exit 1
            fi
            if [ "$FRONTEND_IMAGE_REF" != "ghcr.io/${GITHUB_REPOSITORY_OWNER}/dorami-frontend:${IMAGE_TAG}" ]; then
              echo "ERROR: frontend image mismatch (expected ghcr.io/${GITHUB_REPOSITORY_OWNER}/dorami-frontend:${IMAGE_TAG}, got $FRONTEND_IMAGE_REF)"
              exit 1
            fi
            echo "Backend image immutable check passed: $BACKEND_IMAGE_REF ($BACKEND_IMAGE_ID)"
            echo "Frontend image immutable check passed: $FRONTEND_IMAGE_REF ($FRONTEND_IMAGE_ID)"

            echo "=== Ensuring uploads directory is writable ==="
            mkdir -p /opt/dorami/backend/uploads
            chmod 777 /opt/dorami/backend/uploads

            echo "=== Setting up SSL certificate (if not exists) ==="
            STAGING_DOMAIN=$(grep -oP "staging\.[^/]+" <<< "${{ vars.STAGING_URL }}" || echo "staging.doremi-live.com")
            if [ ! -f /opt/dorami/nginx/ssl/fullchain.pem ] || [ ! -f /opt/dorami/nginx/ssl/privkey.pem ]; then
              echo "SSL certificates not found. Setting up Certbot..."

              # Install Certbot if not present
              command -v certbot > /dev/null || {
                echo "Installing Certbot..."
                sudo apt-get update -qq
                sudo apt-get install -y certbot
              }

              # Stop Nginx to free port 80
              docker compose -f docker-compose.base.yml -f docker-compose.staging.yml stop nginx || true
              sleep 2

              # Issue certificate
              echo "Requesting Let's Encrypt certificate for ${STAGING_DOMAIN}..."
              sudo certbot certonly \
                --standalone \
                --email admin@doremi-live.com \
                --agree-tos \
                --non-interactive \
                --force-renewal \
                -d "${STAGING_DOMAIN}" || {
                echo "WARNING: Certbot failed. Continuing with HTTP mode..."
              }

              # Copy certificates if they were created
              if [ -d "/etc/letsencrypt/live/${STAGING_DOMAIN}" ]; then
                echo "Copying certificates to nginx/ssl/..."
                mkdir -p nginx/ssl
                sudo cp /etc/letsencrypt/live/${STAGING_DOMAIN}/fullchain.pem nginx/ssl/
                sudo cp /etc/letsencrypt/live/${STAGING_DOMAIN}/privkey.pem nginx/ssl/
                sudo chmod 644 nginx/ssl/fullchain.pem nginx/ssl/privkey.pem
                sudo chown $(id -u):$(id -g) nginx/ssl/*
                echo "✓ SSL certificates installed"
              fi
            else
              echo "✓ SSL certificates already exist"
            fi

            echo "=== Resolving any failed migrations ==="
            docker compose -f docker-compose.base.yml -f docker-compose.staging.yml run --rm -T backend npx prisma migrate resolve --rolled-back 20260224000000_add_free_shipping_threshold < /dev/null 2>/dev/null || true

            echo "=== Running database migrations ==="
            docker compose -f docker-compose.base.yml -f docker-compose.staging.yml run --rm -T backend npx prisma migrate deploy < /dev/null

            echo "=== Restarting services ==="
            docker compose -f docker-compose.base.yml -f docker-compose.staging.yml up -d --force-recreate --remove-orphans

            echo "=== Cleaning up old images ==="
            docker image prune -af --filter "until=1h"

            echo "=== Checking service health ==="
            for i in 1 2 3 4 5 6; do
              if curl -sf http://localhost:3001/api/health/live > /dev/null 2>&1; then
                echo "Backend healthy!"
                break
              fi
              if [ "\$i" = "6" ]; then
                echo "Backend health check failed after 6 attempts"
                docker compose -f docker-compose.base.yml -f docker-compose.staging.yml logs backend --tail=50
                exit 1
              fi
              echo "Waiting for backend... (attempt \$i/6)"
              sleep 15
            done

            for i in 1 2 3 4 5 6; do
              if curl -sf http://localhost:3000 > /dev/null 2>&1; then
                echo "Frontend healthy!"
                break
              fi
              if [ "\$i" = "6" ]; then
                echo "Frontend health check failed after 6 attempts"
                docker compose -f docker-compose.base.yml -f docker-compose.staging.yml logs frontend --tail=50
                exit 1
              fi
              echo "Waiting for frontend... (attempt \$i/6)"
              sleep 10
            done

            echo "=== Deployment complete ==="
          ENDSSH

      - name: Notify Success
        if: success()
        run: |
          echo "Staging deployment successful!"
          echo "Image tag: ${{ needs.build.outputs.image_tag }}"
          echo "URL: ${{ secrets.STAGING_URL }}"

      - name: Notify Failure
        if: failure()
        run: |
          echo "Staging deployment failed!"
          exit 1

  # ===========================================
  # Post-deployment Smoke Tests (via SSH)
  # ===========================================
  smoke-test:
    name: Smoke Tests
    needs: [deploy]
    if: always() && needs.deploy.result == 'success'
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - name: Setup SSH
        env:
          SSH_KEY: ${{ secrets.STAGING_SSH_KEY }}
          SSH_HOST: ${{ secrets.STAGING_HOST }}
        run: |
          mkdir -p ~/.ssh
          KEY_OK=false
          printf '%s\n' "$SSH_KEY" | tr -d '\r' > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          if ssh-keygen -y -f ~/.ssh/id_rsa > /dev/null 2>&1; then
            echo "SSH key loaded (raw PEM)"
            KEY_OK=true
          fi
          if [ "$KEY_OK" = "false" ]; then
            if printf '%s' "$SSH_KEY" | tr -d ' \r\n' | base64 -d > ~/.ssh/id_rsa 2>/dev/null; then
              chmod 600 ~/.ssh/id_rsa
              if ssh-keygen -y -f ~/.ssh/id_rsa > /dev/null 2>&1; then
                echo "SSH key loaded (base64)"
                KEY_OK=true
              fi
            fi
          fi
          if [ "$KEY_OK" = "false" ]; then
            echo "ERROR: SSH key invalid. len=${#SSH_KEY} has_begin=$(printf '%s' "$SSH_KEY" | grep -c BEGIN || echo 0)"
            exit 1
          fi
          ssh-keyscan -H "$SSH_HOST" >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Health Check - Backend
        run: |
          ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} \
            'curl -sf -o /dev/null -w "%{http_code}" http://localhost:3001/api/health/live'
          echo "Backend health check passed"

      - name: Health Check - Frontend
        run: |
          ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} \
            'curl -sf -o /dev/null -w "%{http_code}" http://localhost:3000'
          echo "Frontend health check passed"

      - name: API Response Test
        run: |
          ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} \
            'curl -s http://localhost:3001/api/health/live'

      - name: Upload Smoke Test
        run: |
          ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} 'bash -s' << 'EOF'
          set -e
          echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==" | base64 -d > /tmp/smoke.png
          # Dev login → JWT cookie
          curl -sf -X POST http://localhost:3001/api/auth/dev-login \
            -H "Content-Type: application/json" \
            -d '{"email":"smoke@test.local","name":"Smoke"}' \
            -c /tmp/smoke-cookies.txt -o /dev/null
          # Upload test image
          STATUS=$(curl -sf -o /dev/null -w "%{http_code}" \
            -X POST http://localhost:3001/api/upload/image \
            -b /tmp/smoke-cookies.txt \
            -F "file=@/tmp/smoke.png;type=image/png")
          rm -f /tmp/smoke.png /tmp/smoke-cookies.txt
          [ "$STATUS" = "201" ] || [ "$STATUS" = "200" ] || { echo "FAIL: Upload returned $STATUS"; exit 1; }
          echo "PASSED: Upload ($STATUS)"
          EOF

      - name: SRS & Live Stream Health Check
        run: |
          ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} 'bash -s' << 'EOF'
          set -e
          # SRS HTTP API (port 1985)
          STATUS=$(curl -sf -o /dev/null -w "%{http_code}" http://localhost:1985/api/v1/versions 2>/dev/null || echo "000")
          [ "$STATUS" = "200" ] || { echo "FAIL: SRS API returned $STATUS (expected 200)"; exit 1; }
          echo "PASSED: SRS API ($STATUS)"
          # RTMP port 1935
          nc -zw3 localhost 1935 && echo "PASSED: RTMP port 1935" || { echo "FAIL: RTMP port 1935 unreachable"; exit 1; }
          # nginx → SRS HTTP-FLV routing (non-streaming → 404/200, never 502)
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost/live/live/smoke-check.flv 2>/dev/null || echo "000")
          [ "$STATUS" != "502" ] && [ "$STATUS" != "000" ] || { echo "FAIL: HTTP-FLV routing broken ($STATUS)"; exit 1; }
          echo "PASSED: HTTP-FLV route ($STATUS)"
          # nginx → SRS HLS routing
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost/hls/smoke-check.m3u8 2>/dev/null || echo "000")
          [ "$STATUS" != "502" ] && [ "$STATUS" != "000" ] || { echo "FAIL: HLS routing broken ($STATUS)"; exit 1; }
          echo "PASSED: HLS route ($STATUS)"
          # Live page
          STATUS=$(curl -sf -o /dev/null -w "%{http_code}" http://localhost:3000/live 2>/dev/null || echo "000")
          [ "$STATUS" = "200" ] || [ "$STATUS" = "307" ] || { echo "FAIL: Live page returned $STATUS"; exit 1; }
          echo "PASSED: Live page ($STATUS)"
          echo "All SRS & live stream checks passed"
          EOF

      - name: Compare staging parity against production
        id: parity_check
        if: always() && needs.deploy.result == 'success'
        env:
          STAGING_URL: ${{ vars.STAGING_URL }}
          PRODUCTION_URL: ${{ vars.PRODUCTION_URL }}
        run: |
          if [ -z "${STAGING_URL}" ] || [ -z "${PRODUCTION_URL}" ]; then
            echo "ERROR: vars.STAGING_URL and vars.PRODUCTION_URL are required for parity check."
            exit 1
          fi

          node scripts/streaming-parity-check.mjs \
            --staging-url "$STAGING_URL" \
            --production-url "$PRODUCTION_URL" \
            --stream-key smoke-check \
            --max-latency-ms 2500

  soak-gate:
    name: Streaming Soak Gate (staging)
    needs: [smoke-test]
    if: always() && needs.smoke-test.result == 'success'
    uses: ./.github/workflows/streaming-soak.yml
    with:
      url: ${{ vars.STAGING_URL }}
      duration: 900
      interval: 30
      max_users: 300
      stream_key: smoke-check
    secrets:
      STAGING_SSH_KEY: ${{ secrets.STAGING_SSH_KEY }}
      STAGING_USER: ${{ secrets.STAGING_USER }}
      STAGING_HOST: ${{ secrets.STAGING_HOST }}
