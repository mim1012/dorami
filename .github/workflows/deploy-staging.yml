# Staging Deployment Workflow
# Automatically deploys to staging when code is pushed to develop branch
# Can also be triggered manually

name: Deploy to Staging

on:
  push:
    branches: [develop]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests before deployment'
        required: false
        default: 'false'
        type: boolean

concurrency:
  group: staging-deployment
  cancel-in-progress: false

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/dorami

jobs:
  # ===========================================
  # Run CI Tests First
  # ===========================================
  test:
    name: Run Tests
    if: ${{ github.event_name == 'workflow_dispatch' && !inputs.skip_tests }}
    uses: ./.github/workflows/ci.yml

  # ===========================================
  # Build and Push Docker Images (unified)
  # ===========================================
  build:
    name: Build Images
    needs: [test]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    uses: ./.github/workflows/build-images.yml
    permissions:
      contents: read
      packages: write

  # ===========================================
  # Deploy to Staging Server
  # ===========================================
  deploy:
    name: Deploy to Staging
    needs: [build]
    if: always() && needs.build.result == 'success'
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: ${{ vars.STAGING_URL }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup SSH
        env:
          SSH_KEY: ${{ secrets.STAGING_SSH_KEY }}
          SSH_HOST: ${{ secrets.STAGING_HOST }}
        run: |
          mkdir -p ~/.ssh
          KEY_OK=false
          printf '%s\n' "$SSH_KEY" | tr -d '\r' > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          if ssh-keygen -y -f ~/.ssh/id_rsa > /dev/null 2>&1; then
            echo "SSH key loaded (raw PEM)"
            KEY_OK=true
          fi
          if [ "$KEY_OK" = "false" ]; then
            if printf '%s' "$SSH_KEY" | tr -d ' \r\n' | base64 -d > ~/.ssh/id_rsa 2>/dev/null; then
              chmod 600 ~/.ssh/id_rsa
              if ssh-keygen -y -f ~/.ssh/id_rsa > /dev/null 2>&1; then
                echo "SSH key loaded (base64)"
                KEY_OK=true
              fi
            fi
          fi
          if [ "$KEY_OK" = "false" ]; then
            echo "ERROR: SSH key invalid. len=${#SSH_KEY} has_begin=$(printf '%s' "$SSH_KEY" | grep -c BEGIN || echo 0)"
            exit 1
          fi
          ssh-keyscan -H "$SSH_HOST" >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Deploy via SSH
        env:
          HOST: ${{ secrets.STAGING_HOST }}
          USER: ${{ secrets.STAGING_USER }}
          IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          KAKAO_CLIENT_ID: ${{ secrets.STAGING_KAKAO_CLIENT_ID }}
          KAKAO_CLIENT_SECRET: ${{ secrets.STAGING_KAKAO_CLIENT_SECRET }}
          ADMIN_EMAILS: ${{ secrets.STAGING_ADMIN_EMAILS }}
        run: |
          ssh $USER@$HOST << ENDSSH
            set -e

            cd /opt/dorami

            echo "=== Pulling latest code ==="
            git fetch origin ${{ github.ref_name }}
            git reset --hard origin/${{ github.ref_name }}

            echo "=== Cleaning up old images ==="
            docker image prune -af --filter "until=24h" || true
            docker builder prune -af --filter "until=24h" || true
            echo "Disk usage after cleanup:"
            df -h / | tail -1

            echo "=== Logging into GHCR ==="
            echo "${GHCR_TOKEN}" | docker login ghcr.io -u ${GITHUB_REPOSITORY_OWNER} --password-stdin

            echo "=== Pulling new images ==="
            export IMAGE_TAG=${IMAGE_TAG}
            export GITHUB_REPOSITORY_OWNER=${GITHUB_REPOSITORY_OWNER}
            export STAGING_HOST=${HOST}
            export KAKAO_CLIENT_ID=${KAKAO_CLIENT_ID}
            export KAKAO_CLIENT_SECRET=${KAKAO_CLIENT_SECRET}
            export ADMIN_EMAILS=${ADMIN_EMAILS}
            docker compose -f docker-compose.staging.yml pull

            echo "=== Ensuring uploads directory is writable ==="
            mkdir -p /opt/dorami/backend/uploads
            chmod 777 /opt/dorami/backend/uploads

            echo "=== Resolving any failed migrations ==="
            docker compose -f docker-compose.staging.yml run --rm -T backend npx prisma migrate resolve --rolled-back 20260224000000_add_free_shipping_threshold < /dev/null 2>/dev/null || true

            echo "=== Running database migrations ==="
            docker compose -f docker-compose.staging.yml run --rm -T backend npx prisma migrate deploy < /dev/null

            echo "=== Restarting services ==="
            docker compose -f docker-compose.staging.yml up -d --force-recreate --remove-orphans

            echo "=== Cleaning up old images ==="
            docker image prune -af --filter "until=1h"

            echo "=== Checking service health ==="
            for i in 1 2 3 4 5 6; do
              if curl -sf http://localhost:3001/api/health/live > /dev/null 2>&1; then
                echo "Backend healthy!"
                break
              fi
              if [ "\$i" = "6" ]; then
                echo "Backend health check failed after 6 attempts"
                docker compose -f docker-compose.staging.yml logs backend --tail=50
                exit 1
              fi
              echo "Waiting for backend... (attempt \$i/6)"
              sleep 15
            done

            for i in 1 2 3 4 5 6; do
              if curl -sf http://localhost:3000 > /dev/null 2>&1; then
                echo "Frontend healthy!"
                break
              fi
              if [ "\$i" = "6" ]; then
                echo "Frontend health check failed after 6 attempts"
                docker compose -f docker-compose.staging.yml logs frontend --tail=50
                exit 1
              fi
              echo "Waiting for frontend... (attempt \$i/6)"
              sleep 10
            done

            echo "=== Deployment complete ==="
          ENDSSH

      - name: Notify Success
        if: success()
        run: |
          echo "Staging deployment successful!"
          echo "Image tag: ${{ needs.build.outputs.image_tag }}"
          echo "URL: ${{ secrets.STAGING_URL }}"

      - name: Notify Failure
        if: failure()
        run: |
          echo "Staging deployment failed!"
          exit 1

  # ===========================================
  # Post-deployment Smoke Tests (via SSH)
  # ===========================================
  smoke-test:
    name: Smoke Tests
    needs: [deploy]
    if: always() && needs.deploy.result == 'success'
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - name: Setup SSH
        env:
          SSH_KEY: ${{ secrets.STAGING_SSH_KEY }}
          SSH_HOST: ${{ secrets.STAGING_HOST }}
        run: |
          mkdir -p ~/.ssh
          KEY_OK=false
          printf '%s\n' "$SSH_KEY" | tr -d '\r' > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          if ssh-keygen -y -f ~/.ssh/id_rsa > /dev/null 2>&1; then
            echo "SSH key loaded (raw PEM)"
            KEY_OK=true
          fi
          if [ "$KEY_OK" = "false" ]; then
            if printf '%s' "$SSH_KEY" | tr -d ' \r\n' | base64 -d > ~/.ssh/id_rsa 2>/dev/null; then
              chmod 600 ~/.ssh/id_rsa
              if ssh-keygen -y -f ~/.ssh/id_rsa > /dev/null 2>&1; then
                echo "SSH key loaded (base64)"
                KEY_OK=true
              fi
            fi
          fi
          if [ "$KEY_OK" = "false" ]; then
            echo "ERROR: SSH key invalid. len=${#SSH_KEY} has_begin=$(printf '%s' "$SSH_KEY" | grep -c BEGIN || echo 0)"
            exit 1
          fi
          ssh-keyscan -H "$SSH_HOST" >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Health Check - Backend
        run: |
          ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} \
            'curl -sf -o /dev/null -w "%{http_code}" http://localhost:3001/api/health/live'
          echo "Backend health check passed"

      - name: Health Check - Frontend
        run: |
          ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} \
            'curl -sf -o /dev/null -w "%{http_code}" http://localhost:3000'
          echo "Frontend health check passed"

      - name: API Response Test
        run: |
          ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} \
            'curl -s http://localhost:3001/api/health/live'

      - name: Upload Smoke Test
        run: |
          ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} 'bash -s' << 'EOF'
          set -e
          echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==" | base64 -d > /tmp/smoke.png
          # Dev login → JWT cookie
          curl -sf -X POST http://localhost:3001/api/auth/dev-login \
            -H "Content-Type: application/json" \
            -d '{"email":"smoke@test.local","name":"Smoke"}' \
            -c /tmp/smoke-cookies.txt -o /dev/null
          # Upload test image
          STATUS=$(curl -sf -o /dev/null -w "%{http_code}" \
            -X POST http://localhost:3001/api/upload/image \
            -b /tmp/smoke-cookies.txt \
            -F "file=@/tmp/smoke.png;type=image/png")
          rm -f /tmp/smoke.png /tmp/smoke-cookies.txt
          [ "$STATUS" = "201" ] || [ "$STATUS" = "200" ] || { echo "FAIL: Upload returned $STATUS"; exit 1; }
          echo "PASSED: Upload ($STATUS)"
          EOF

      - name: SRS & Live Stream Health Check
        run: |
          ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} 'bash -s' << 'EOF'
          set -e
          # SRS HTTP API (port 1985)
          STATUS=$(curl -sf -o /dev/null -w "%{http_code}" http://localhost:1985/api/v1/versions 2>/dev/null || echo "000")
          [ "$STATUS" = "200" ] || { echo "FAIL: SRS API returned $STATUS (expected 200)"; exit 1; }
          echo "PASSED: SRS API ($STATUS)"
          # RTMP port 1935
          nc -zw3 localhost 1935 && echo "PASSED: RTMP port 1935" || { echo "FAIL: RTMP port 1935 unreachable"; exit 1; }
          # nginx → SRS HTTP-FLV routing (non-streaming → 404/200, never 502)
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost/live/live/smoke-check.flv 2>/dev/null || echo "000")
          [ "$STATUS" != "502" ] && [ "$STATUS" != "000" ] || { echo "FAIL: HTTP-FLV routing broken ($STATUS)"; exit 1; }
          echo "PASSED: HTTP-FLV route ($STATUS)"
          # nginx → SRS HLS routing
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost/hls/smoke-check.m3u8 2>/dev/null || echo "000")
          [ "$STATUS" != "502" ] && [ "$STATUS" != "000" ] || { echo "FAIL: HLS routing broken ($STATUS)"; exit 1; }
          echo "PASSED: HLS route ($STATUS)"
          # Live page
          STATUS=$(curl -sf -o /dev/null -w "%{http_code}" http://localhost:3000/live 2>/dev/null || echo "000")
          [ "$STATUS" = "200" ] || [ "$STATUS" = "307" ] || { echo "FAIL: Live page returned $STATUS"; exit 1; }
          echo "PASSED: Live page ($STATUS)"
          echo "All SRS & live stream checks passed"
          EOF
