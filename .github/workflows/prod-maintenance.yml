name: Production Maintenance

on:
  workflow_dispatch:
    inputs:
      command:
        description: 'Maintenance command to run'
        required: true
        default: 'status'
        type: choice
        options:
          - status
          - show-db-env
          - test-db-auth-tcp
          - test-db-auth-network
          - test-db-url-parse
          - inspect-backend-db-url
          - repair-db-auth
          - repair-redis-auth
          - sync-db-env
          - diagnose
          - fix-ssl
          - fix-ports
          - fix-stream-ports
          - test-srs-ingest
          - check-nginx-upstream
          - logs-backend
          - logs-frontend
          - logs-proxy
          - logs-srs
          - db-check
          - db-restore
          - find-data
          - restart-backend
          - restart-frontend
          - restart-srs
          - restart-all

jobs:
  run:
    name: Run Maintenance Command
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Guard - main branch only
        if: github.event_name == 'workflow_dispatch'
        run: |
          if [ "${GITHUB_REF}" != "refs/heads/main" ]; then
            echo "ERROR: Production maintenance must run from main branch."
            echo "Current ref: ${GITHUB_REF}"
            exit 1
          fi

      - name: Setup SSH
        env:
          SSH_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
          HOST: ${{ secrets.PRODUCTION_HOST }}
        run: |
          mkdir -p ~/.ssh
          if printf '%s' "$SSH_KEY" | grep -q "BEGIN"; then
            printf '%s\n' "$SSH_KEY" | tr -d '\r' > ~/.ssh/id_rsa
          else
            printf '%s' "$SSH_KEY" | base64 -d > ~/.ssh/id_rsa
          fi
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "$HOST" >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts
          ssh-keygen -y -f ~/.ssh/id_rsa > /dev/null && echo "SSH key OK" || { echo "SSH key invalid"; exit 1; }

      - name: status
        if: inputs.command == 'status'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          echo "=== 컨테이너 상태 ==="
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          echo "=== 디스크 ==="
          df -h / && docker system df
          EOF

      - name: show-db-env
        if: inputs.command == 'show-db-env'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          set -euo pipefail
          echo "=== PostgreSQL container env ==="
          PGUSER=$(docker exec dorami-postgres-prod env | grep '^POSTGRES_USER=' | cut -d= -f2 || true)
          PGDB=$(docker exec dorami-postgres-prod env | grep '^POSTGRES_DB=' | cut -d= -f2 || true)
          PGPASS=$(docker exec dorami-postgres-prod env | grep '^POSTGRES_PASSWORD=' | cut -d= -f2 || true)
          echo "POSTGRES_USER(container): ${PGUSER}"
          echo "POSTGRES_DB(container):   ${PGDB}"
          echo "POSTGRES_PASSWORD(container): [hidden length=${#PGPASS}]"
          echo ""
          echo "=== /opt/dorami/.env.production values ==="
          grep -E '^(POSTGRES_USER|POSTGRES_DB)=' /opt/dorami/.env.production || true
          if grep -q '^POSTGRES_PASSWORD=' /opt/dorami/.env.production; then
            LEN=$(grep '^POSTGRES_PASSWORD=' /opt/dorami/.env.production | cut -d= -f2- | wc -c)
            echo "POSTGRES_PASSWORD(.env.production): [hidden length=$((LEN-1))]"
          else
            echo "POSTGRES_PASSWORD(.env.production): [missing]"
          fi
          EOF

      - name: test-db-auth-tcp
        if: inputs.command == 'test-db-auth-tcp'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          set -euo pipefail

          cd /opt/dorami
          if [ ! -f .env.production ]; then
            echo "ERROR: /opt/dorami/.env.production not found"
            exit 1
          fi

          set -a
          source .env.production
          set +a

          echo "=== TCP auth test with .env.production credentials ==="
          docker exec \
            -e PGPASSWORD="${POSTGRES_PASSWORD}" \
            dorami-postgres-prod \
            psql -h 127.0.0.1 -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" -c "SELECT 1;" >/tmp/db-auth-env.out 2>/tmp/db-auth-env.err \
            && echo "ENV_TCP_AUTH=PASS" \
            || (echo "ENV_TCP_AUTH=FAIL"; cat /tmp/db-auth-env.err; exit 1)

          echo "=== Local socket auth (reference) ==="
          docker exec dorami-postgres-prod psql -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" -c "SELECT 1;" >/tmp/db-auth-local.out 2>/tmp/db-auth-local.err \
            && echo "LOCAL_AUTH=PASS" \
            || (echo "LOCAL_AUTH=FAIL"; cat /tmp/db-auth-local.err; exit 1)
          EOF

      - name: test-db-auth-network
        if: inputs.command == 'test-db-auth-network'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          set -euo pipefail

          cd /opt/dorami
          set -a
          source .env.production
          set +a

          NETWORK=$(docker inspect dorami-postgres-prod --format '{{range $k,$v := .NetworkSettings.Networks}}{{printf "%s\n" $k}}{{end}}' | head -1)
          if [ -z "${NETWORK}" ]; then
            echo "ERROR: postgres network not found"
            exit 1
          fi

          echo "=== Network auth test from sidecar container ==="
          docker run --rm \
            --network "${NETWORK}" \
            -e PGPASSWORD="${POSTGRES_PASSWORD}" \
            postgres:16-alpine \
            psql -h postgres -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" -c "SELECT 1;" >/tmp/db-auth-net.out 2>/tmp/db-auth-net.err \
            && echo "NETWORK_AUTH=PASS" \
            || (echo "NETWORK_AUTH=FAIL"; cat /tmp/db-auth-net.err; exit 1)
          EOF

      - name: test-db-url-parse
        if: inputs.command == 'test-db-url-parse'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          set -euo pipefail

          cd /opt/dorami
          set -a
          source .env.production
          set +a

          URL="postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}?schema=public&connection_limit=20&pool_timeout=30"
          export URL POSTGRES_USER POSTGRES_PASSWORD

          python3 - << 'PY'
          import os
          import urllib.parse

          url = os.environ["URL"]
          raw_pw = os.environ["POSTGRES_PASSWORD"]
          parsed = urllib.parse.urlparse(url)
          parsed_pw = urllib.parse.unquote(parsed.password or "")

          print("URL_PARSE_SCHEME=", parsed.scheme)
          print("URL_PARSE_HOST=", parsed.hostname)
          print("URL_PARSE_DB=", parsed.path.lstrip("/"))
          print("URL_PARSE_USER_MATCH=", str((parsed.username or "") == os.environ["POSTGRES_USER"]))
          print("URL_PARSE_PASSWORD_LEN=", len(parsed_pw))
          print("ENV_PASSWORD_LEN=", len(raw_pw))
          print("URL_PARSE_PASSWORD_MATCH=", str(parsed_pw == raw_pw))
          print("URL_AT_COUNT=", url.count("@"))
          PY
          EOF

      - name: inspect-backend-db-url
        if: inputs.command == 'inspect-backend-db-url'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          set -euo pipefail

          cd /opt/dorami
          set -a
          source .env.production
          set +a

          BACKEND_URL=$(docker inspect dorami-backend-prod --format '{{range .Config.Env}}{{println .}}{{end}}' 2>/dev/null | grep '^DATABASE_URL=' | sed 's/^DATABASE_URL=//')
          if [ -z "${BACKEND_URL}" ]; then
            echo "ERROR: DATABASE_URL not found in backend container env"
            exit 1
          fi

          export BACKEND_URL POSTGRES_USER POSTGRES_PASSWORD POSTGRES_DB
          python3 - << 'PY'
          import os
          import urllib.parse

          backend_url = os.environ["BACKEND_URL"]
          parsed = urllib.parse.urlparse(backend_url)
          parsed_pw = urllib.parse.unquote(parsed.password or "")

          print("BACKEND_URL_SCHEME=", parsed.scheme)
          print("BACKEND_URL_HOST=", parsed.hostname)
          print("BACKEND_URL_DB=", parsed.path.lstrip("/"))
          print("BACKEND_URL_USER_MATCH=", str((parsed.username or "") == os.environ["POSTGRES_USER"]))
          print("BACKEND_URL_PASSWORD_LEN=", len(parsed_pw))
          print("ENV_PASSWORD_LEN=", len(os.environ["POSTGRES_PASSWORD"]))
          print("BACKEND_URL_PASSWORD_MATCH=", str(parsed_pw == os.environ["POSTGRES_PASSWORD"]))
          PY
          EOF

      - name: repair-db-auth
        if: inputs.command == 'repair-db-auth'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          set -euo pipefail

          cd /opt/dorami
          set -a
          source .env.production
          set +a

          echo "=== Repair DB auth (no data/schema change) ==="
          ESCAPED_PASS=${POSTGRES_PASSWORD//\'/\'\'}
          docker exec dorami-postgres-prod \
            psql -U postgres -d postgres -v ON_ERROR_STOP=1 \
            -c "ALTER USER \"${POSTGRES_USER}\" WITH PASSWORD '${ESCAPED_PASS}';"

          NETWORK=$(docker inspect dorami-postgres-prod --format '{{range $k,$v := .NetworkSettings.Networks}}{{printf "%s\n" $k}}{{end}}' | head -1)
          if [ -z "${NETWORK}" ]; then
            echo "ERROR: postgres network not found"
            exit 1
          fi

          echo "=== Verify network auth ==="
          docker run --rm \
            --network "${NETWORK}" \
            -e PGPASSWORD="${POSTGRES_PASSWORD}" \
            postgres:16-alpine \
            psql -h postgres -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" -c "SELECT 1;" >/tmp/db-auth-net.out 2>/tmp/db-auth-net.err \
            && echo "NETWORK_AUTH=PASS" \
            || (echo "NETWORK_AUTH=FAIL"; cat /tmp/db-auth-net.err; exit 1)

          echo "=== Recreate backend ==="
          docker compose -f docker-compose.prod.yml --env-file .env.production \
            up -d --no-deps --force-recreate backend

          echo "=== Wait backend health ==="
          ok=false
          for i in $(seq 1 24); do
            status=$(docker inspect --format='{{.State.Health.Status}}' dorami-backend-prod 2>/dev/null || echo "unknown")
            if [ "$status" = "healthy" ]; then
              ok=true
              echo "Backend healthy"
              break
            fi
            if [ "$status" = "unhealthy" ]; then
              echo "Backend unhealthy"
              docker logs dorami-backend-prod --tail=80 2>/dev/null || true
              exit 1
            fi
            echo "Waiting backend... $i/24 (status=$status)"
            sleep 5
          done

          if [ "$ok" != "true" ]; then
            echo "ERROR: backend health timeout"
            docker logs dorami-backend-prod --tail=80 2>/dev/null || true
            exit 1
          fi

          echo "=== Recreate frontend ==="
          docker compose -f docker-compose.prod.yml --env-file .env.production \
            up -d --no-deps --force-recreate frontend || true

          echo "=== Final status ==="
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          EOF

      - name: repair-redis-auth
        if: inputs.command == 'repair-redis-auth'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          set -euo pipefail

          cd /opt/dorami
          if [ ! -f .env.production ]; then
            echo "ERROR: /opt/dorami/.env.production not found"
            exit 1
          fi

          echo "=== Resolve Redis password from running container ==="
          REDIS_PASS_CONTAINER=$(docker inspect dorami-redis-prod --format '{{range .Config.Cmd}}{{println .}}{{end}}' \
            | awk 'prev=="--requirepass"{print; exit}{prev=$0}')
          if [ -z "${REDIS_PASS_CONTAINER}" ]; then
            echo "ERROR: failed to extract Redis password from dorami-redis-prod"
            exit 1
          fi

          REDIS_PASS_ENV=$(grep '^REDIS_PASSWORD=' .env.production | head -1 | cut -d= -f2- || true)
          echo "REDIS_PASSWORD(container): [hidden length=${#REDIS_PASS_CONTAINER}]"
          if [ -n "${REDIS_PASS_ENV}" ]; then
            echo "REDIS_PASSWORD(.env.production): [hidden length=${#REDIS_PASS_ENV}]"
          else
            echo "REDIS_PASSWORD(.env.production): [missing]"
          fi

          if [ "${REDIS_PASS_ENV}" != "${REDIS_PASS_CONTAINER}" ]; then
            echo "=== Sync REDIS_PASSWORD into .env.production ==="
            TMP=$(mktemp)
            awk -v v="${REDIS_PASS_CONTAINER}" '
              BEGIN { done=0 }
              /^REDIS_PASSWORD=/ {
                if (!done) {
                  print "REDIS_PASSWORD=" v
                  done=1
                }
                next
              }
              { print }
              END {
                if (!done) {
                  print "REDIS_PASSWORD=" v
                }
              }
            ' .env.production > "${TMP}"
            mv "${TMP}" .env.production
            chmod 600 .env.production || true
            echo "REDIS_PASSWORD synced"
          else
            echo "REDIS_PASSWORD already synced"
          fi

          NETWORK=$(docker inspect dorami-redis-prod --format '{{range $k,$v := .NetworkSettings.Networks}}{{printf "%s\n" $k}}{{end}}' | head -1)
          if [ -z "${NETWORK}" ]; then
            echo "ERROR: redis network not found"
            exit 1
          fi

          echo "=== Verify Redis auth on network ==="
          docker run --rm \
            --network "${NETWORK}" \
            redis:7-alpine \
            redis-cli -h redis -a "${REDIS_PASS_CONTAINER}" ping >/tmp/redis-auth-net.out 2>/tmp/redis-auth-net.err \
            && grep -q '^PONG' /tmp/redis-auth-net.out \
            && echo "REDIS_NETWORK_AUTH=PASS" \
            || (echo "REDIS_NETWORK_AUTH=FAIL"; cat /tmp/redis-auth-net.err; cat /tmp/redis-auth-net.out || true; exit 1)

          echo "=== Recreate backend with synced REDIS_PASSWORD ==="
          docker compose -f docker-compose.prod.yml --env-file .env.production \
            up -d --no-deps --force-recreate backend

          echo "=== Wait backend health ==="
          ok=false
          for i in $(seq 1 24); do
            status=$(docker inspect --format='{{.State.Health.Status}}' dorami-backend-prod 2>/dev/null || echo "unknown")
            if [ "$status" = "healthy" ]; then
              ok=true
              echo "Backend healthy"
              break
            fi
            if [ "$status" = "unhealthy" ]; then
              echo "Backend unhealthy"
              docker logs dorami-backend-prod --tail=120 2>/dev/null || true
              exit 1
            fi
            echo "Waiting backend... $i/24 (status=$status)"
            sleep 5
          done

          if [ "$ok" != "true" ]; then
            echo "ERROR: backend health timeout"
            docker logs dorami-backend-prod --tail=120 2>/dev/null || true
            exit 1
          fi

          echo "=== Final status ==="
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          EOF

      - name: sync-db-env
        if: inputs.command == 'sync-db-env'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          set -euo pipefail

          echo "=== Reading PostgreSQL container env ==="
          PGUSER=$(docker exec dorami-postgres-prod env | grep '^POSTGRES_USER=' | cut -d= -f2)
          PGDB=$(docker exec dorami-postgres-prod env | grep '^POSTGRES_DB=' | cut -d= -f2)
          PGPASS=$(docker exec dorami-postgres-prod env | grep '^POSTGRES_PASSWORD=' | cut -d= -f2-)

          echo "Container POSTGRES_USER=${PGUSER}"
          echo "Container POSTGRES_DB=${PGDB}"
          echo "Container POSTGRES_PASSWORD=[hidden length=${#PGPASS}]"

          cd /opt/dorami
          if [ ! -f .env.production ]; then
            echo "ERROR: /opt/dorami/.env.production not found"
            exit 1
          fi

          echo "=== Syncing .env.production ==="
          sed -i "s|^POSTGRES_USER=.*|POSTGRES_USER=${PGUSER}|" .env.production \
            || echo "POSTGRES_USER=${PGUSER}" >> .env.production
          sed -i "s|^POSTGRES_DB=.*|POSTGRES_DB=${PGDB}|" .env.production \
            || echo "POSTGRES_DB=${PGDB}" >> .env.production
          sed -i "s|^POSTGRES_PASSWORD=.*|POSTGRES_PASSWORD=${PGPASS}|" .env.production \
            || echo "POSTGRES_PASSWORD=${PGPASS}" >> .env.production

          echo "=== Recreate backend/frontend with synced DB env ==="
          docker compose -f docker-compose.prod.yml --env-file .env.production \
            up -d --no-deps --force-recreate backend frontend

          echo "=== Waiting for backend health ==="
          ok=false
          for i in $(seq 1 24); do
            status=$(docker inspect --format='{{.State.Health.Status}}' dorami-backend-prod 2>/dev/null || echo "unknown")
            if [ "$status" = "healthy" ]; then
              ok=true
              echo "Backend healthy"
              break
            fi
            if [ "$status" = "unhealthy" ]; then
              echo "Backend unhealthy"
              docker logs dorami-backend-prod --tail=50 2>/dev/null || true
              exit 1
            fi
            echo "Waiting backend... $i/24 (status=$status)"
            sleep 5
          done

          if [ "$ok" != "true" ]; then
            echo "ERROR: backend health timeout"
            docker logs dorami-backend-prod --tail=80 2>/dev/null || true
            exit 1
          fi

          echo "=== Final container status ==="
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          EOF

      - name: logs-backend
        if: inputs.command == 'logs-backend'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: ssh $USER@$HOST 'docker logs dorami-backend-prod --tail=200 2>&1'

      - name: logs-frontend
        if: inputs.command == 'logs-frontend'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: ssh $USER@$HOST 'docker logs dorami-frontend-prod --tail=200 2>&1'

      - name: logs-proxy
        if: inputs.command == 'logs-proxy'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: ssh $USER@$HOST 'docker logs dorami-proxy-prod --tail=200 2>&1'

      - name: logs-srs
        if: inputs.command == 'logs-srs'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: ssh $USER@$HOST 'docker logs dorami-srs-prod --tail=200 2>&1'

      - name: db-check
        if: inputs.command == 'db-check'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          echo "=== 백업 파일 ==="
          ls -lah /opt/dorami/backups/ 2>/dev/null || echo "(없음)"
          echo "=== users ==="
          docker exec dorami-postgres-prod bash -c 'PGPASSWORD=$POSTGRES_PASSWORD psql -U $POSTGRES_USER -d $POSTGRES_DB -t -c "SELECT COUNT(*) FROM users;"' 2>&1 || echo "fail"
          echo "=== products ==="
          docker exec dorami-postgres-prod bash -c 'PGPASSWORD=$POSTGRES_PASSWORD psql -U $POSTGRES_USER -d $POSTGRES_DB -t -c "SELECT COUNT(*) FROM products;"' 2>&1 || echo "fail"
          echo "=== live_streams ==="
          docker exec dorami-postgres-prod bash -c 'PGPASSWORD=$POSTGRES_PASSWORD psql -U $POSTGRES_USER -d $POSTGRES_DB -t -c "SELECT COUNT(*) FROM live_streams;"' 2>&1 || echo "fail"
          echo "=== orders ==="
          docker exec dorami-postgres-prod bash -c 'PGPASSWORD=$POSTGRES_PASSWORD psql -U $POSTGRES_USER -d $POSTGRES_DB -t -c "SELECT COUNT(*) FROM orders;"' 2>&1 || echo "fail"
          EOF

      - name: db-restore
        if: inputs.command == 'db-restore'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          set -euo pipefail
          LATEST=$(ls -t /opt/dorami/backups/db_backup_*.sql.gz 2>/dev/null | head -1)
          if [ -z "$LATEST" ]; then
            echo "ERROR: 백업 없음"
            exit 1
          fi
          echo "복구: $LATEST"
          PGUSER=$(docker exec dorami-postgres-prod env | grep POSTGRES_USER | cut -d= -f2)
          PGPASS=$(docker exec dorami-postgres-prod env | grep POSTGRES_PASSWORD | cut -d= -f2)
          PGDB=$(docker exec dorami-postgres-prod env | grep POSTGRES_DB | cut -d= -f2)
          zcat "$LATEST" | docker exec -i dorami-postgres-prod bash -c "PGPASSWORD=$PGPASS psql -U $PGUSER -d $PGDB"
          docker restart dorami-backend-prod
          sleep 15
          docker inspect --format='Health: {{.State.Health.Status}}' dorami-backend-prod 2>/dev/null
          echo "완료!"
          EOF

      - name: find-data
        if: inputs.command == 'find-data'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          echo "=== Docker 볼륨 전체 목록 ==="
          docker volume ls
          echo "=== 삭제된 컨테이너 포함 전체 ==="
          docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.CreatedAt}}" 2>&1 | head -30
          echo "=== PG_VERSION 파일 검색 ==="
          find / -name "PG_VERSION" 2>/dev/null | head -10
          echo "=== /opt 디렉토리 구조 ==="
          ls -lah /opt/ 2>/dev/null
          ls -lah /opt/live-commerce/ 2>/dev/null || echo "/opt/live-commerce 없음"
          ls -lah /opt/dorami/ 2>/dev/null || echo "/opt/dorami 없음"
          echo "=== /var/lib/docker/volumes 목록 ==="
          ls -lah /var/lib/docker/volumes/ 2>/dev/null || sudo ls -lah /var/lib/docker/volumes/ 2>/dev/null || echo "접근 불가"
          echo "=== /home/ubuntu 구조 ==="
          ls -lah /home/ubuntu/ 2>/dev/null || echo "(없음)"
          echo "=== live-commerce 관련 docker 볼륨 ==="
          docker volume ls | grep -i "live\|commerce\|postgres\|pg" || echo "관련 볼륨 없음"
          EOF

      - name: diagnose
        if: inputs.command == 'diagnose'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          echo "=== 포트 바인딩 (ss) ==="
          ss -tlnp | grep -E ':80|:443|:3000|:3001|:8080' || echo "(없음)"
          echo "=== Docker 포트 바인딩 상세 ==="
          docker inspect dorami-frontend-prod --format '포트: {{json .HostConfig.PortBindings}}' 2>/dev/null
          docker inspect dorami-backend-prod --format '포트: {{json .HostConfig.PortBindings}}' 2>/dev/null
          echo "=== PM2 프로세스 ==="
          pm2 list 2>/dev/null || echo "PM2 없음"
          echo "=== Host Nginx 설정 ==="
          cat /etc/nginx/sites-enabled/* 2>/dev/null || cat /etc/nginx/conf.d/*.conf 2>/dev/null || echo "설정 파일 없음"
          echo "=== docker-compose.prod.yml ports 섹션 ==="
          grep -A3 "ports:" /opt/dorami/docker-compose.prod.yml 2>/dev/null || echo "파일 없음"
          EOF

      - name: fix-ports
        if: inputs.command == 'fix-ports'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          set -euo pipefail
          echo "=== PM2 중지 ==="
          pm2 stop all 2>/dev/null || true
          pm2 delete all 2>/dev/null || true
          echo "=== 포트 점유 프로세스 종료 ==="
          fuser -k 3000/tcp 2>/dev/null || true
          fuser -k 3001/tcp 2>/dev/null || true
          sleep 2
          echo "=== frontend/backend force-recreate ==="
          cd /opt/dorami
          docker compose -f docker-compose.prod.yml --env-file .env.production \
            up -d --no-deps --force-recreate backend frontend
          echo "=== 결과 ==="
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          EOF

      - name: fix-stream-ports
        if: inputs.command == 'fix-stream-ports'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          set -euo pipefail

          cd /opt/dorami
          echo "=== SRS force-recreate (apply host port bindings) ==="
          docker compose -f docker-compose.prod.yml --env-file .env.production \
            up -d --no-deps --force-recreate srs

          echo "=== wait for 8080 listener ==="
          ok=false
          for i in $(seq 1 24); do
            if ss -tln | grep -q ':8080'; then
              ok=true
              echo "SRS port 8080 is listening"
              break
            fi
            echo "waiting 8080... $i/24"
            sleep 3
          done

          if [ "$ok" != "true" ]; then
            echo "ERROR: 8080 listener not ready"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            docker logs dorami-srs-prod --tail=120 2>/dev/null || true
            exit 1
          fi

          echo "=== verify container ports ==="
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "dorami-srs-prod|NAMES"
          EOF

      - name: test-srs-ingest
        if: inputs.command == 'test-srs-ingest'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          set -euo pipefail

          STREAM_KEY="smoke$(date +%s)"
          LOG_FILE="/tmp/srs-smoke-${STREAM_KEY}.log"
          echo "STREAM_KEY=${STREAM_KEY}"

          echo "=== precheck: srs container and listener ==="
          docker ps --format '{{.Names}}' | grep -q '^dorami-srs-prod$' || { echo "ERROR: dorami-srs-prod not running"; exit 1; }
          ss -tln | grep -q ':1935' || { echo "ERROR: RTMP 1935 not listening"; exit 1; }
          ss -tln | grep -q ':8080' || { echo "ERROR: HTTP 8080 not listening"; exit 1; }

          echo "=== start synthetic RTMP publish (15s) ==="
          if command -v ffmpeg >/dev/null 2>&1; then
            ffmpeg -hide_banner -loglevel error -re \
              -f lavfi -i testsrc=size=640x360:rate=15 \
              -f lavfi -i anullsrc=r=44100:cl=stereo \
              -shortest -t 15 \
              -c:v libx264 -preset veryfast -tune zerolatency -pix_fmt yuv420p \
              -c:a aac -ar 44100 -b:a 96k \
              -f flv "rtmp://127.0.0.1:1935/live/${STREAM_KEY}" > "${LOG_FILE}" 2>&1 &
          else
            docker run --rm --network host jrottenberg/ffmpeg:6.0-alpine \
              -hide_banner -loglevel error -re \
              -f lavfi -i testsrc=size=640x360:rate=15 \
              -f lavfi -i anullsrc=r=44100:cl=stereo \
              -shortest -t 15 \
              -c:v libx264 -preset veryfast -tune zerolatency -pix_fmt yuv420p \
              -c:a aac -ar 44100 -b:a 96k \
              -f flv "rtmp://127.0.0.1:1935/live/${STREAM_KEY}" > "${LOG_FILE}" 2>&1 &
          fi
          PUB_PID=$!
          trap 'kill ${PUB_PID} 2>/dev/null || true' EXIT

          echo "=== probe outputs while publishing ==="
          FLV_OK=false
          HLS_OK=false
          LAST_FLV_CODE=000
          LAST_HLS_CODE=000
          for i in $(seq 1 25); do
            FLV_CODE=$(curl --max-time 2 -s -o /dev/null -w "%{http_code}" "http://127.0.0.1:8080/live/live/${STREAM_KEY}.flv" || true)
            HLS_CODE=$(curl --max-time 2 -s -o /dev/null -w "%{http_code}" "http://127.0.0.1:8080/live/${STREAM_KEY}.m3u8" || true)
            LAST_FLV_CODE="${FLV_CODE}"
            LAST_HLS_CODE="${HLS_CODE}"
            echo "probe ${i}: flv=${FLV_CODE}, hls=${HLS_CODE}"
            if [ "${FLV_CODE}" = "200" ]; then
              FLV_OK=true
            fi
            if [ "${HLS_CODE}" = "200" ]; then
              HLS_OK=true
            fi
            if [ "${FLV_OK}" = "true" ] || [ "${HLS_OK}" = "true" ]; then
              break
            fi
            sleep 1
          done

          PUBLIC_HLS_CODE=$(curl --max-time 3 -s -o /dev/null -w "%{http_code}" "https://www.doremi-live.com/hls/${STREAM_KEY}.m3u8" || true)
          PUBLIC_FLV_CODE=$(curl --max-time 3 -s -o /dev/null -w "%{http_code}" "https://www.doremi-live.com/live/live/${STREAM_KEY}.flv" || true)

          wait ${PUB_PID} || true
          trap - EXIT

          if [ "${FLV_OK}" != "true" ] && [ "${HLS_OK}" != "true" ]; then
            echo "ERROR: no playable output during ingest"
            echo "LAST_FLV_CODE=${LAST_FLV_CODE}, LAST_HLS_CODE=${LAST_HLS_CODE}"
            echo "--- ffmpeg log ---"
            cat "${LOG_FILE}" || true
            echo "--- srs log tail ---"
            docker logs dorami-srs-prod --tail=120 2>/dev/null || true
            exit 1
          fi

          echo "SRS_INGEST_TEST=PASS"
          echo "STREAM_KEY=${STREAM_KEY}"
          echo "LOCAL_FLV_OK=${FLV_OK} LOCAL_HLS_OK=${HLS_OK}"
          echo "PUBLIC_FLV_CODE=${PUBLIC_FLV_CODE} PUBLIC_HLS_CODE=${PUBLIC_HLS_CODE}"
          echo "Playback candidates:"
          echo "  FLV: https://www.doremi-live.com/live/live/${STREAM_KEY}.flv"
          echo "  HLS: https://www.doremi-live.com/hls/${STREAM_KEY}.m3u8"
          EOF

      - name: check-nginx-upstream
        if: inputs.command == 'check-nginx-upstream'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          set -euo pipefail

          echo "=== nginx error.log upstream keywords (last 300 lines) ==="
          if [ -r /var/log/nginx/error.log ]; then
            tail -n 300 /var/log/nginx/error.log \
              | grep -E 'upstream|connect\(\) failed|timed out|no live upstreams|502' \
              || echo "(no upstream error keywords)"
          else
            sudo tail -n 300 /var/log/nginx/error.log 2>/dev/null \
              | grep -E 'upstream|connect\(\) failed|timed out|no live upstreams|502' \
              || echo "(no upstream error keywords or no permission)"
          fi

          echo "=== nginx access.log 502 entries (last 500 lines) ==="
          if [ -r /var/log/nginx/access.log ]; then
            tail -n 500 /var/log/nginx/access.log | awk '$9==502{print}' | tail -n 50 || true
          else
            sudo tail -n 500 /var/log/nginx/access.log 2>/dev/null | awk '$9==502{print}' | tail -n 50 || true
          fi

          echo "=== direct upstream probes ==="
          echo -n "frontend(3000): "
          curl --max-time 3 -s -o /dev/null -w "%{http_code}" http://127.0.0.1:3000/ || true
          echo
          echo -n "backend(3001/live): "
          curl --max-time 3 -s -o /dev/null -w "%{http_code}" http://127.0.0.1:3001/api/health/live || true
          echo
          echo -n "srs(8080/hls missing): "
          curl --max-time 3 -s -o /dev/null -w "%{http_code}" http://127.0.0.1:8080/live/nonexistent.m3u8 || true
          echo
          EOF

      - name: fix-ssl
        if: inputs.command == 'fix-ssl'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          echo "=== 호스트 인증서 확인 ==="
          ls /etc/letsencrypt/live/ 2>/dev/null || echo "호스트에 letsencrypt 없음"
          echo "=== certbot_conf 볼륨 내용 ==="
          docker run --rm -v dorami_certbot_conf:/etc/letsencrypt alpine ls /etc/letsencrypt/live/ 2>/dev/null || echo "볼륨 비어있음"
          echo "=== 호스트 → Docker 볼륨 인증서 복사 ==="
          if [ -d /etc/letsencrypt/live/doremi-live.com ]; then
            docker run --rm \
              -v /etc/letsencrypt:/host-letsencrypt:ro \
              -v dorami_certbot_conf:/etc/letsencrypt \
              alpine sh -c "cp -r /host-letsencrypt/live /host-letsencrypt/archive /host-letsencrypt/renewal /etc/letsencrypt/ 2>/dev/null; ls /etc/letsencrypt/live/"
            echo "복사 완료"
          else
            echo "호스트에 doremi-live.com 인증서 없음 — certbot 직접 발급 시도"
            docker stop dorami-proxy-prod 2>/dev/null || true
            docker run --rm \
              -v dorami_certbot_conf:/etc/letsencrypt \
              -v dorami_certbot_www:/var/www/certbot \
              -p 80:80 \
              certbot/certbot certonly --standalone \
              -d doremi-live.com -d www.doremi-live.com \
              --email admin@dorami.shop \
              --agree-tos --no-eff-email --non-interactive 2>&1
          fi
          echo "=== nginx-proxy 재시작 ==="
          cd /opt/dorami
          docker compose -f docker-compose.prod.yml --env-file .env.production \
            up -d --no-deps --force-recreate nginx-proxy
          sleep 5
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "proxy|NAME"
          docker logs dorami-proxy-prod --tail=10 2>&1
          EOF

      - name: restart-backend
        if: inputs.command == 'restart-backend'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: ssh $USER@$HOST 'docker restart dorami-backend-prod && echo "완료"'

      - name: restart-frontend
        if: inputs.command == 'restart-frontend'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: ssh $USER@$HOST 'docker restart dorami-frontend-prod && echo "완료"'

      - name: restart-srs
        if: inputs.command == 'restart-srs'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: ssh $USER@$HOST 'docker restart dorami-srs-prod && echo "완료"'

      - name: restart-all
        if: inputs.command == 'restart-all'
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh $USER@$HOST bash << 'EOF'
          docker restart dorami-backend-prod dorami-frontend-prod dorami-srs-prod
          docker ps --format "table {{.Names}}\t{{.Status}}"
          EOF
