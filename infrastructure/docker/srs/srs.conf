listen              1935;
max_connections     5000;
daemon              off;
srs_log_tank        console;
srs_log_level       warn;

# Worker threads for multi-core utilization
threads             4;

http_server {
    enabled         on;
    listen          8080;
    crossdomain     on;
}

http_api {
    enabled         on;
    listen          1985;
    crossdomain     on;
}

# Heartbeat for monitoring (reports to backend every 9.9s)
heartbeat {
    enabled         on;
    interval        9.9;
    url             http://backend:3001/api/v1/streaming/srs-heartbeat;
}

stats {
    network         0;
}

vhost __defaultVhost__ {
    # Inbound limits: reject abnormal publishers
    publish {
        mr          off;
        firstpkt_timeout    10000;
        normal_timeout      30000;
    }

    # Outbound: client-side play settings
    play {
        gop_cache           on;
        gop_cache_max_frames 30;
        queue_length        1;
        mw_latency          0;
    }

    # HTTP-FLV remux (primary low-latency output)
    http_remux {
        enabled     on;
        mount       [vhost]/live/[app]/[stream].flv;
    }

    # HLS (fallback, higher compatibility)
    # hls_path must match SRS HTTP server root (./objs/nginx/html)
    # so that the builtin HTTP server can serve .m3u8 and .ts files
    hls {
        enabled             on;
        hls_path            ./objs/nginx/html;
        # hls_wait_keyframe on → 실제 fragment는 keyframe interval(~1s)에 맞춰짐
        # 0.5s 설정은 wait_keyframe과 충돌해 효과없음 → 1s 유지
        hls_fragment        1;
        hls_window          4;
        hls_cleanup         on;
        hls_wait_keyframe   on;
    }

    # SRS webhook callbacks to backend
    http_hooks {
        enabled         on;
        on_publish      http://backend:3001/api/v1/streaming/srs-auth;
        on_unpublish    http://backend:3001/api/v1/streaming/srs-done;
    }

    # Low-latency tuning
    # Note: min_latency conflicts with gop_cache and HLS; keep off
    tcp_nodelay     on;
}
