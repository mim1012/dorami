# 1인 셀러 라이브 커머스 MVP: 프론트엔드 기술 스택 및 구현 가이드

## 1. 문서 개요

본 문서는 "1인 셀러 라이브 커머스 MVP 플랫폼" 모바일 애플리케이션의 성공적인 프론트엔드 개발을 위한 기술 스택 선정, 아키텍처, 그리고 핵심 기능 구현 가이드를 제공합니다. 이 가이드는 기 작성된 `design_system.md`와 `ui_ux_specification.md`를 기술적으로 구현하는 것을 목표로 합니다.

## 2. 프론트엔드 기술 스택 (Technology Stack)

프로젝트의 목표인 빠른 MVP 개발, 모바일 최적화, 그리고 실시간 기능 구현을 고려하여 다음과 같은 기술 스택을 제안합니다.

| 구분 | 기술 | 선정 사유 |
|---|---|---|
| **Core Framework** | **React Native (with Expo)** | 단일 코드베이스로 iOS와 Android 앱을 동시에 개발하여 MVP 기간(2개월) 내 빠른 출시가 가능합니다. Expo를 사용하여 네이티브 모듈 설정의 복잡성을 줄이고 개발 생산성을 극대화합니다. |
| **Language** | **TypeScript** | 정적 타입을 통해 코드의 안정성과 유지보수성을 높입니다. 복잡한 데이터 구조(상품, 주문 등)를 다루는 커머스 앱에서 발생할 수 있는 런타임 에러를 사전에 방지합니다. |
| **State Management** | **Zustand** | 가볍고 직관적인 API를 제공하여 React Hooks에 익숙한 개발자가 쉽게 학습하고 사용할 수 있습니다. Boilerplate가 적어 코드량이 감소하며, 전역 상태(로그인, 장바구니 등)를 효율적으로 관리할 수 있습니다. |
| **Styling** | **Styled Components** | 컴포넌트 기반의 스타일링을 통해 `design_system.md`에 정의된 디자인 시스템(색상, 타이포그래피 등)을 체계적으로 적용하고 재사용성을 높입니다. 동적 스타일링(테마, 상태 기반)이 용이하여 다크 모드 구현에 적합합니다. |
| **Navigation** | **React Navigation** | React Native 생태계의 표준 내비게이션 라이브러리로, 하단 탭 바, 모달, 화면 간 전환 등 복잡한 사용자 플로우를 안정적으로 구현할 수 있습니다. |
| **Data Fetching** | **React Query (TanStack Query)** | 서버 데이터(상품 목록, 주문 내역 등)의 Fetching, Caching, 동기화, 업데이트 로직을 자동화하여 비즈니스 로직에 집중할 수 있게 합니다. 로딩 및 에러 상태를 손쉽게 관리할 수 있습니다. |
| **Real-time Comms** | **Socket.IO Client** | WebSocket 통신을 간편하게 구현하여 라이브 채팅, 실시간 재고 업데이트, 시청자 수 변동 등 핵심적인 실시간 기능을 안정적으로 처리합니다. |

## 3. 프로젝트 아키텍처 및 폴더 구조

유지보수성과 확장성을 고려하여 다음과 같은 폴더 구조를 제안합니다.

```
/src
|-- /api // API 호출 함수
|-- /assets // 폰트, 이미지 등 정적 자원
|-- /components // 재사용 가능한 UI 컴포넌트 (Atoms, Molecules)
|   |-- /common // 버튼, 인풋 등 범용 컴포넌트
|   |-- /domain // 상품 카드, 채팅창 등 특정 도메인 컴포넌트
|-- /constants // 상수 값 (API URL, 색상 코드 등)
|-- /hooks // 커스텀 훅
|-- /navigation // React Navigation 관련 설정
|-- /screens // 각 화면 컴포넌트
|-- /store // Zustand 스토어 (상태 관리)
|-- /styles // 전역 스타일, 테마 등
|-- /types // TypeScript 타입 정의
|-- /utils // 유틸리티 함수
```

## 4. 핵심 기능 구현 가이드

### 4.1. 디자인 시스템 구현
- **위치**: `/src/styles/theme.ts`, `/src/constants/colors.ts`
- **가이드**: `design_system.md`에 정의된 색상 팔레트, 타이포그래피 스케일을 `theme.ts` 파일에 객체 형태로 정의합니다. Styled Components의 `ThemeProvider`를 사용하여 앱 전체에 테마를 주입합니다. 이를 통해 모든 컴포넌트에서 `theme.colors.hotPink`와 같은 형태로 디자인 토큰에 일관되게 접근할 수 있습니다.

### 4.2. 실시간 라이브 방송 화면 (LIVE-01)
- **비디오 스트리밍**: `react-native-video` 또는 Expo의 `AV` 모듈을 사용하여 HLS/DASH 스트림을 재생합니다. 백엔드에서 제공하는 스트리밍 URL을 받아 플레이어에 연결합니다.
- **실시간 채팅**: 화면 진입 시 Socket.IO 클라이언트를 초기화하고 서버에 연결합니다. `useEffect` 훅을 사용하여 소켓 이벤트 리스너(예: `new_message`, `user_joined`)를 등록하고, 수신된 데이터를 Zustand 스토어에 업데이트하여 화면에 렌더링합니다. 화면을 벗어날 때 소켓 연결을 정리(cleanup)하여 메모리 누수를 방지합니다.
- **실시간 재고**: 채팅과 마찬가지로, `stock_update`와 같은 소켓 이벤트를 수신하여 특정 상품의 재고 상태를 업데이트하고, 이를 하단 상품 캐러셀과 옵션 선택 모달에 즉시 반영합니다.

### 4.3. 장바구니 타이머 로직 (CART-01)
- **서버 시간 기준 동기화**: 타이머의 기준 시간은 반드시 서버 시간을 사용해야 합니다. 클라이언트의 로컬 시간은 사용자가 임의로 변경할 수 있어 신뢰할 수 없습니다.
- **구현 방식**:
    1. 사용자가 상품을 장바구니에 담으면, 백엔드는 해당 장바구니의 만료 시각(`expiresAt`)을 데이터베이스에 저장하고 클라이언트에 전달합니다.
    2. 클라이언트는 `expiresAt`과 현재 시각의 차이를 계산하여 남은 시간을 표시합니다.
    3. `setInterval`을 사용하여 1초마다 남은 시간을 다시 계산하고 UI를 업데이트합니다.
    4. 앱이 백그라운드로 전환되거나 재실행되어도, 화면이 다시 활성화될 때 `expiresAt`을 기준으로 남은 시간을 정확하게 다시 계산하여 보여줍니다.
    5. 타이머가 0에 도달하면, 사용자에게 알림을 표시하고 서버에 장바구니 비우기 API를 호출합니다.

### 4.4. 전역 상태 관리
- **Zustand 스토어 설계**: 인증 상태(`AuthStore`), 장바구니 정보(`CartStore`), 사용자 정보(`UserStore`) 등 도메인별로 스토어를 분리하여 관리합니다.
- **예시 (`CartStore`)**:
    - **State**: `items` (상품 배열), `expiresAt` (만료 시각)
    - **Actions**: `addItem`, `removeItem`, `clearCart`, `setExpiresAt`
- 컴포넌트에서는 `const { items, addItem } = useCartStore();` 와 같이 훅을 사용하여 간단하게 상태와 액션을 가져와 사용합니다.

## 5. 개발자 협업 가이드

- **코드 컨벤션**: `ESLint`와 `Prettier`를 설정하여 일관된 코드 스타일을 유지합니다.
- **커밋 메시지**: "feat: 로그인 화면 UI 구현", "fix: 장바구니 타이머 오류 수정"과 같이 Conventional Commits 규칙을 따라 커밋 히스토리를 명확하게 관리합니다.
- **브랜치 전략**: `Git-flow` 또는 `GitHub-flow`와 같은 브랜치 전략을 사용하여 기능 개발, 릴리즈, 핫픽스를 체계적으로 관리합니다.
